#!/usr/bin/env python

"""
extract-control.py --input <infile>.gff > <outfile>.fasta

This script takes an input of a gff file (usually generated by Proka) with a
##FASTA section containing the sequence data, and outputs a FASTA file of all
the control regions found. The script is capable of finding control regions in
reverse complemented and rotated sequences, unless the feature is split across
the start/end of the sequence.

The general process is as follows:
    + Annotations for the Ile-tRNA and 12S rRNA are located.
    + If necessary, adjustments are made for reverse complemented and
        roatated sequences.
    + the appropriate section of the FASTA section is extracted and printed to
        standard output.

 !! This script has only been tested with mosquito mitogenomes, but should !!
 !! be capable of extracting control regions from any mitogenome bounded   !!
 !! by Ile-tRNA and 12S rRNA                                               !!
"""

#   Make the sequences print to files instead of being held in memory?
#   Extend the system to clip any control region, given command line arguments for the annotation boundaries

# command line arguments, regular expressions
import argparse
import re

def get_params():
    """Returns the command line arguments."""

    parser = argparse.ArgumentParser(description="""
        This script takes an input of a gff file (usually generated by Proka) with a
        ##FASTA section containing the sequence data, and outputs a FASTA file of all
        the control regions found. The script is capable of finding control regions in
        reverse complemented and rotated sequences, unless the feature is split across
        the start/end of the sequence. Output is done through standard output.
        """.strip())
    parser.add_argument("--input", help="The file to be worked on. GFF format with a ##FASTA section.")

    return parser.parse_args()

class SeqInfo:
    """
    Stores information about the sequences and where they get clipped, reverse comp, rotation, etc.
    Also has some methods to deal with looking for the boundaries, finding the control region, etc.
    """

    # start annotation is annotation that should be on the near end of the final outputted control sequence.
    # end is the same but for the far end.
    start_anno_5_prime = -1
    start_anno_3_prime = -1
    end_anno_5_prime = -1
    end_anno_3_prime = -1
    clipped_before = ""
    clipped_after = ""
    inner_flag = False
    rev_comp = False

    def check_flip(self):
        """
        toggles inner_flag if the features has been flipped from the expected orientation (5'-B---A-3' instead of 5'-A---B-3').
        """

        ## safety for sequences when they're both found, and the END sequence is after
        if (self.start_anno_5_prime != -1
                and self.end_anno_5_prime != -1
                and self.end_anno_5_prime < self.start_anno_5_prime):
            self.inner_flag = (not self.inner_flag) # take from between instead of the tails
            # it has to be a toggle instead of an assignment because of weirdnesss with rotated reverse complements.

    def get_bounds(self, words, bound_start_pattern, bound_end_pattern):
        """
        Finds the patterns for the boundaries we're looking for in the gff data and
        saves the start/end positions. It also checks if the end bound is reversed
        from the expected orientation and marks the sequence as reversed if it is.
        """

        # Sections of the gff format (to make this less opaque):
        # [0] sequence ID
        # [1] source (usually a program name)
        # [2] feature type
        # [3] start of feature
        # [4] end of feature
        # [5] score (???)
        # [6] + or - strand
        # [7] phase (reading frame) relative to the start of the annotation
        # [8] attributes: other information

        ## only use the first tRNA-Ile
        if (self.start_anno_5_prime < 0
                and bound_start_pattern.search(words[8])):
            self.start_anno_5_prime = int(words[3]) - 1
            self.start_anno_3_prime = int(words[4])
            self.check_flip()
        if bound_end_pattern.search(words[8]):
            self.end_anno_5_prime = int(words[3]) - 1
            self.end_anno_3_prime = int(words[4])
            # operating under the assumption that the 12S rRNA is on the negative strand
            # so if it isn't, we assume that we're looking at the reverse complement of what we're normally looking at
            if words[6] == "+":
                self.rev_comp = True
                # we have to set inner flag to be "flipped" because of the orientation of the sequence.
                self.inner_flag = True

                # let me essplane:
                #
                # Normal: 5'~tRNA------->12S>~~3'          | Reverse complement: 3'~~<12S<-------tRNA~5'
                # the tRNA is before the rRNA, so we take  | The rRNA is before the tRNA, but we still have
                # from the start, until the tRNA, then     | to take the outer. Because the rotation checker
                # from the rRNA to the end.                | only checks for the position of the rRNA vs tRNA,
                #                                          | it'll see the 12S before and decide that we need
                #                                          | to take the centre, which is false. So we pre-set
                #                                          | it to true to trick it into being correct by
                #                                          | toggling itself back to getting the edges.
                #------------------------------------------+--------------------------------------------------
                # Rotated: 5'--->12S>~~~tRNA----3'         | Rotated RevComp: 3'----tRNA~~~<12S<---5'
                # The 12S rRNA is before the tRNA, so we   | We want the centre, but since the 12S is after
                # take the inner sequence, not the edges.  | the tRNA, the rotation checker will ignore it as
                # The rotation checker will see the 12S    | correct, and take the edges unless we set it to
                # before the tRNA and switch to taking the | true (which we did).
                # middle instead of the edges.             |


                # Is this a kludgy hack born out of tech debt? Probably. Still works, tho
            self.check_flip()

    def parse_seq(self, words, current_base):
        """
        Clips the relevant sequence data from sequences.

        There are four possible states for the sequence:
        - Normal orientation
        - reverse complement
        - annotations in reverse order (sequence has been rotated)
        - reverse complement rotated

        In a normal orientation, it gets sequence data from the 1 position, to the
        start of the "near" annotation, then skips all nucleotides until the end of the
        "end" annotation. These sequences are then concatenated together.

        In the reverse complement, it still grabs data from the edges, but from 1 to the
        start of the "far" annotation, and after the end of the "near" annotation. These
        annotation are only "near" and "far" in reference to the normal orientation. In
        the reverse complement, they get reversed.

        In reverse order, it gets from the end of the "far" to the start of the "near"
        sequence. Again, the annotations are only far/near in reference to the normal
        orientation of the sequence.

        In the reverse complement reverse order, it gets from the end of the "start" to
        the start of the "end." In this case, it's double reversed so the annotation names
        actually bodge their way to being correct.

        Every time this iterates through, it adds nucleotides to "clipped_before" and/or
        "clipped_after", and increments the current base.
        """

        # if the line doesn't start with >, and clipCounter >= 0
        # then you start
        if (current_base >= 0) and (words[0][:1] != ">"):
            # if we're looking at the reverse complement, we need to flip the boundaries.
            if self.rev_comp:
                near_bound = self.end_anno_5_prime
                far_bound = self.start_anno_3_prime
            else:
                near_bound = self.start_anno_5_prime
                far_bound = self.end_anno_3_prime

            ## DEFAULT BEHAVIOUR:
            #  take from before the tRNA and then after the rRNA
            # clip from the start until whenever the tRNA begins
            if not self.inner_flag:
                self.clipped_before += words[0][
                    :max(0, near_bound - current_base)]

                # Clip after getting to the end of the rRNA
                self.clipped_after += words[0][
                    max(0, (far_bound - current_base)):]

            ## MODIFIED BEHAVIOUR:
            #  Take BETWEEN the rRNA and the tRNA.
            # This is "backwards" because the expected far bound is nearer when this happens.
            else:
                self.clipped_after += words[0][
                    max(0, (far_bound - current_base)):
                    max(0, near_bound - current_base)]

            ## This always happens
            # return the number of nt parsed so we can increment the counter
            return len(words[0])
        # if we find nothing, just return 0.
        return 0

# biopython can also do this, but I feel like it's easier to do it this way if I just need the one thing.
# makes a translation dictionary in case of reverse compliments
NT_ALL  = "AGCTURYKMBVDH" # everything else will get ignored -> '-', 'N', "S", "W" get "complemented" to themselves
NT_COMP = "TCGAAYRMKVBHD"
# build the dictionary and store it
NT_COMP_DICT = str.maketrans(NT_ALL+NT_ALL.lower(), NT_COMP+NT_COMP.lower())

# Uses the library defined just above to get the other strand, then reverses the string
def reverse_comp(seq):
    """returns the reverse complement string of a sequence string."""
    return seq.translate(NT_COMP_DICT)[::-1]

def prepare_line(line):
    """clips the newline off and splits by tabs."""
    return line.strip().split("\t")

def main():
    """Main CLI entry point for extract-control.py"""
    args = get_params()

    # dictionary of sequences indexed by name
    seqs = {}

    with open(args.input, 'r') as seq_file:

        # The annotation you want the cut to START at
        bound_start_pattern = re.compile(r'product=mtRNA-Ile\(...\)') ## escaped regex
        # The annotation the cut ENDS at
        bound_end_pattern = re.compile(r'product=12S ribosomal RNA')

        # current base position being parsed
        current_base = -1

        # name of the sequence being clipped
        clipping_seq = None

        for line in seq_file:
            words = prepare_line(line)

            # stop trying to add new sequences when we get to the fasta section
            if words[0][:7] == "##FASTA":
                break
            # skip all other ## lines
            if words[0][:2] == "##":
                continue

            # if we're looking for new sequences
            # if the sequence name isn't indexed already, index it
            if not words[0] in seqs:
                seqs[words[0]] = SeqInfo()

            #try to find the boundaries of the control region on this sequence by looking for the boundary annotations
            seqs[words[0]].get_bounds(words, bound_start_pattern, bound_end_pattern)

        # if we're into the fasta section, after hitting ##FASTA
        for line in seq_file:
            words = prepare_line(line)

            # New fasta sequence, start trimming the sequence for the control region
            if words[0][:1] == ">":
                current_base = 0
                clipping_seq = words[0][1:]

            # continue clipping the control region out.
            if clipping_seq in seqs:
                current_base += seqs[clipping_seq].parse_seq(words, current_base)

    for i in seqs:
        print(">"+i+"_cont_reg")
        seq = seqs[i].clipped_after+seqs[i].clipped_before
        if seqs[i].rev_comp:
            seq = reverse_comp(seq)
        print(seq)

if __name__ == '__main__':
    main()
